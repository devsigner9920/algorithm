import time
# 당신은 음식점의 계산을 도와주는 점원이다.
# 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 
# 존재한다고 가정한다.
# 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수를 구하라.
# 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.

multiple_num = 126         # 배수
change = 10 * multiple_num # 거스름돈
cnt = 0                    # 거스름돈 동전 수
money_list = [500, 100, 50, 10]

####################################################################################
####################################내가 짠 코드####################################
start_time = time.time()
for money in money_list:
    q, r = divmod(change, money) # 거스름돈 / 동전(크기 순)

    if q < 1:     # 거슬러줄 돈이 없다면 동전이 더 큰 경우 e.g. 100 / 500 == q: 0.2
        continue
    
    change = r # 가장 큰 동전으로 거슬러주고 남은 잔돈
    cnt += q
end_time = time.time()
print(cnt)
print("내가 짠 코드 경과 시간:", end_time - start_time)
####################################################################################
####################################책 풀이 코드####################################
start_time = time.time()
multiple_num = 126         # 배수
change = 10 * multiple_num # 거스름돈
cnt = 0                    # 거스름돈 동전 수

for money in money_list:
    cnt += change // money # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
    change %= money
end_time = time.time()
print(cnt)
print("책 풀이 코드 경과 시간:", end_time - start_time)
####################################################################################
# 그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토해야 한다.
# 거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서
# 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해
# 다른 해가 나올 수 없기 때문이다.
# e.g. 800원 거스름돈, 화폐단위 500원, 400원, 100원
# 이 경우 그리디 알고리즘으로는 4개의 동전(500원 + 100원 + 100원 + 100원)을 거슬러
# 줘야한다고 나오는데, 최적의 해는 2개의 동전(400원 + 400원)을 거슬러 주는 것이다.
# 즉, 원래 문제에서는 큰단위가 작은 단위의 배수 형태이므로,
# 가장 큰 단위의 화폐부터 가장 작은 단위의 화폐까지 차례대로 확인하여 거슬러 주는 
# 작업만을 수행한다는 아이디어는 정당하다.
# 대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를
# 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

    